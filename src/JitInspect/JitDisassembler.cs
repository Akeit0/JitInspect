using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Disassemblers;
using BenchmarkDotNet.Disassemblers.Exporters;
using Microsoft.Diagnostics.Runtime;
using MethodInfo = BenchmarkDotNet.Disassemblers.MethodInfo;

namespace JitInspect;

/// <summary>
/// Provides an method to dump the ASM generated by the current JIT of a <see cref="MethodInfo"/>.
/// </summary>
public sealed class JitDisassembler : IDisposable
{
    static readonly DisassembleOptions defaultOptions = new();
    internal ConcurrentBag<IDisposable> Disposables { get; } = new();
    readonly ClrRuntime runtime;
    readonly ClrMdV3Disassembler disassembler;
    readonly int processId;

    internal JitDisassembler(Process? process)
    {
        var dt = CreateDataTarget(process);
        processId = dt.DataReader.ProcessId;
        var info = dt.ClrVersions[0];
        runtime = info.CreateRuntime();
        Disposables.Add(dt);
        Disposables.Add(runtime);
        disassembler = CreateDisassemblerForCurrentArchitecture();
    }

    public static JitDisassembler Create(Process? process = null)
    {
        return new(process);
    }

    static ClrMdV3Disassembler CreateDisassemblerForCurrentArchitecture()
    {
        return RuntimeInformation.ProcessArchitecture switch
        {
            Architecture.X86 or Architecture.X64 => new IntelDisassembler(),
            Architecture.Arm64 => new Arm64Disassembler(),
            _ => throw new NotSupportedException($"{RuntimeInformation.ProcessArchitecture} is not supported")
        };
    }

    public static DataTarget CreateDataTarget(Process? process = null)
    {
        return DataTarget.AttachToProcess((process ?? Process.GetCurrentProcess()).Id, false);
    }


    /// <summary>
    /// Disassembles the given method.
    /// </summary>
    /// <param name="method">The method to disassemble.</param>
    /// <param name="options">options</param>
    public string Disassemble(MethodBase method, DisassembleOptions? options = null)
    {
        using var writer = new ArrayPoolBufferWriter<char>();
        Disassemble(writer, method, options);
        return writer.AsSpan().ToString();
    }

    /// <summary>
    /// Disassembles the given method of delegate.
    /// </summary>
    /// <param name="delegate">The delegate to disassemble.</param>
    /// <param name="options">options</param>
    public string Disassemble(Delegate @delegate, DisassembleOptions? options = null)
    {
        return Disassemble(@delegate.Method, options);
    }

    /// <summary>
    /// Disassembles the given method and write to IBufferWriter.
    /// </summary>
    /// <param name="writer">The writer to write the disassembled method to.</param>
    /// <param name="method">The method to disassemble.</param>
    /// <param name="options">options</param>
    public void Disassemble(IBufferWriter<char> writer, MethodBase method, DisassembleOptions? options = null)
    {
        options ??= defaultOptions;


        if (method.IsGenericMethodDefinition)
        {
            WriteSignatureFromReflection(writer, method);


            writer.WriteLine("; Open generics cannot be JIT-compiled.");
        }
        else if (method.IsAbstract)
        {
            WriteSignatureFromReflection(writer, method);


            writer.WriteLine("; Abstract method cannot be JIT-compiled.");
        }
        else
        {
            DisassembleConstructedMethod(writer, method, options);
        }
    }

    void DisassembleConstructedMethod(IBufferWriter<char> writer, MethodBase method, DisassembleOptions options)
    {
        var config = new DisassemblyDiagnoserConfig(options.MaxRecursiveDepth,
            printSource: options.PrintSource,
            printInstructionAddresses: options.PrintInstructionAddresses,
            syntax: Convert(options.Syntax));

        var handle = method.MethodHandle;
        handle.GetFunctionPointer();
        RuntimeHelpers.PrepareMethod(handle);
        ClrMethod? clrMethod;
        lock (runtime)
        {
            runtime.FlushCachedData();
        }

        ConfigureSymbols(runtime.DataTarget);
        if (method.IsVirtual && !method.DeclaringType!.IsClass)
            clrMethod = runtime.GetMethodByInstructionPointer((ulong)FunctionPointerHelper.GetMethodPointer((System.Reflection.MethodInfo)method));
        else
            clrMethod = FindJitCompiledMethod(handle);

        if (clrMethod == null)
        {
            writer.WriteLine("; Failed to find JIT output.");
            return;
        }

        var state = new State(runtime, "");
        using var sourceCodeProvider = new SourceCodeProvider();
        var settings = new Settings(processId,
            "Disassembler",
            clrMethod.Signature!,
            options.PrintSource,
            options.MaxRecursiveDepth,
            "",
            Convert(options.Syntax).ToString(),
            "",
            Array.Empty<string>());
        var disassembledMethods = new List<DisassembledMethod>();
        var syntax = (DisassemblySyntax)Enum.Parse(typeof(DisassemblySyntax), settings.Syntax);
        var firstMethod = new MethodInfo(clrMethod, 0);

        state.Todo.Enqueue(firstMethod);

        while (state.Todo.Count != 0)
        {
            var methodInfo = state.Todo.Dequeue();

            if (!state.HandledMethods.Add(methodInfo.Method)) // add it now to avoid StackOverflow for recursive methods
                continue; // already handled

            if (settings.MaxDepth >= methodInfo.Depth)
                disassembledMethods.Add(disassembler.DisassembleMethod(methodInfo, state, settings, config.Syntax, sourceCodeProvider));
        }

        var filteredMethods = disassembledMethods.Count == 1
            ? disassembledMethods // if there is only one method we want to return it (most probably benchmark got inlined)
            : disassembledMethods.Where(static method => !method.Name.Contains(DisassemblerConstants.DisassemblerEntryMethodName));

        var disassemblyResult = new DisassemblyResult
        {
            Methods = filteredMethods.ToArray(),
            SerializedAddressToNameMapping = state.AddressToNameMapping.Select(x => new DisassemblyResult.MutablePair { Key = x.Key, Value = x.Value }).ToArray(),
            PointerSize = (uint)IntPtr.Size
        };
        var methodIndex = 0;
        foreach (var methodInfo in disassembledMethods)
        {
            if (methodIndex != 0) writer.WriteLine();
            writer.Write("; ");
            writer.WriteLine(methodInfo.Name);

            var pretty = DisassemblyPrettifier.Prettify(methodInfo, disassemblyResult, config, $"M{methodIndex++:00}");
            ulong totalSizeInBytes = 0;
            foreach (var element in pretty)
                if (element is DisassemblyPrettifier.Label label)
                {
                    writer.WriteLine($"{label.TextRepresentation}:");
                }
                else if (element.Source is Sharp sharp)
                {
                    writer.WriteLine($"; {sharp.Text.Replace("\n", "\n; ")}"); // they are multiline and we need to add ; for each line
                }
                else if (element.Source is Asm asm)
                {
                    checked
                    {
                        totalSizeInBytes += (uint)asm.InstructionLength;
                    }

                    writer.WriteLine($"       {element.TextRepresentation}");
                }
                else if (element.Source is MonoCode mono)
                {
                    writer.WriteLine(mono.Text);
                }

            writer.WriteLine($"; Total bytes of code {totalSizeInBytes}");
        }
    }

    static BenchmarkDotNet.Diagnosers.DisassemblySyntax Convert(DisassemblySyntax syntax)
    {
        return syntax switch
        {
            DisassemblySyntax.Intel => BenchmarkDotNet.Diagnosers.DisassemblySyntax.Intel,
            DisassemblySyntax.Masm => BenchmarkDotNet.Diagnosers.DisassemblySyntax.Masm,
            DisassemblySyntax.Att => BenchmarkDotNet.Diagnosers.DisassemblySyntax.Att,
            _ => throw new ArgumentOutOfRangeException(nameof(syntax), syntax, null)
        };
    }

    class ILToNativeMapComparer : IEqualityComparer<ILToNativeMap>
    {
        public static readonly ILToNativeMapComparer Instance = new();

        public bool Equals(ILToNativeMap x, ILToNativeMap y)
        {
            return x.ILOffset == y.ILOffset && x.StartAddress == y.StartAddress && x.EndAddress == y.EndAddress;
        }

        public int GetHashCode(ILToNativeMap obj)
        {
            return HashCode.Combine(obj.ILOffset, obj.StartAddress, obj.EndAddress);
        }
    }

    ClrMethod? FindJitCompiledMethod(RuntimeMethodHandle handle)
    {
        var methodDescAddress = unchecked((ulong)handle.Value.ToInt64());
        if (runtime.GetMethodByHandle(methodDescAddress) is not { } method) return null;

        if (method.CompilationType == MethodCompilationType.None || method.NativeCode == 0 || method.HotColdInfo.HotSize == 0) return null;

        return method;
    }

    void WriteTypeName(IBufferWriter<char> writer, Type type)
    {
        if (type.IsGenericType)
        {
            writer.Write(type.GetGenericTypeDefinition().FullName);
            var genericArguments = type.GetGenericArguments();
            if (genericArguments.Length > 0)
            {
                writer.Write("<");
                var first = true;
                foreach (var argument in genericArguments)
                {
                    if (first)
                        first = false;
                    else
                        writer.Write(", ");

                    WriteTypeName(writer, argument);
                }

                writer.Write(">");
                return;
            }
        }

        if (type.IsByRef)
        {
            WriteTypeName(writer, type.GetElementType()!);
            writer.Write(" ByRef");
            return;
        }

        writer.Write(type.FullName ?? type.Name);
    }


    void WriteSignatureFromReflection(IBufferWriter<char> writer, MethodBase method)
    {
        writer.Write("; ");
        if (method.DeclaringType is { } declaringType)
        {
            WriteTypeName(writer, declaringType);

            writer.Write(".");
        }

        writer.Write(method.Name);
        if (method.IsGenericMethod)
        {
            writer.Write("<");
            var first = true;
            foreach (var type in method.GetGenericArguments())
            {
                if (first)
                    first = false;
                else
                    writer.Write(", ");

                WriteTypeName(writer, type);
            }

            writer.Write(">");
        }

        writer.Write("(");
        {
            var first = true;
            foreach (var parameter in method.GetParameters())
            {
                if (first)
                    first = false;
                else
                    writer.Write(", ");

                var type = parameter.ParameterType;
                WriteTypeName(writer, type);
            }
        }
        writer.WriteLine(")");
    }


    static void ConfigureSymbols(DataTarget dataTarget)
    {
        // code copied from https://github.com/Microsoft/clrmd/issues/34#issuecomment-161926535
        dataTarget.SetSymbolPath("http://msdl.microsoft.com/download/symbols");
    }

    public void Dispose()
    {
        foreach (var disposable in Disposables)
            disposable.Dispose();
        Disposables.Clear();
    }
}