using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using BenchmarkDotNet.Disassemblers;
using Iced.Intel;
using Microsoft.Diagnostics.Runtime;
using MethodInfo = BenchmarkDotNet.Disassemblers.MethodInfo;

namespace JitInspect;

/// <summary>
/// Provides an method to dump the ASM generated by the current JIT of a <see cref="MethodInfo"/>.
/// </summary>
public abstract class JitDisassembler : IDisposable
{
    static readonly DisassembleOptions defaultOptions = new DisassembleOptions();
    internal ConcurrentBag<IDisposable> Disposables { get; } = new ConcurrentBag<IDisposable>();
    readonly ClrRuntime runtime;

    internal JitDisassembler()
    {
        var dt = CreateDataTarget();
        var info = dt.ClrVersions[0];
        runtime = info.CreateRuntime();
        Disposables.Add(dt);
        Disposables.Add(runtime);
    }

    public static JitDisassembler Create()
    {
        var arch = System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture;
        switch (arch)
        {
            case Architecture.X86:
            case Architecture.X64: return new IntelDisassembler();
            case Architecture.Arm64:
                return new Arm64Disassembler();
            default:
                throw new NotSupportedException($" {arch} is not supported");
        }
    }


    public static DataTarget CreateDataTarget()
    {
        return DataTarget.AttachToProcess(Process.GetCurrentProcess().Id, false);
    }


    /// <summary>
    /// Disassembles the given method.
    /// </summary>
    /// <param name="method">The method to disassemble.</param>
    /// <param name="options">options</param>
    public string Disassemble(MethodBase method, DisassembleOptions? options = null)
    {
        using var writer = new ArrayPoolBufferWriter<char>();
        Disassemble(writer, method, options);
        return writer.AsSpan().ToString();
    }

    /// <summary>
    /// Disassembles the given method of delegate.
    /// </summary>
    /// <param name="delegate">The delegate to disassemble.</param>
    /// <param name="options">options</param>
    public string Disassemble(Delegate @delegate, DisassembleOptions? options = null)
    {
        return Disassemble(@delegate.Method, options);
    }

    /// <summary>
    /// Disassembles the given method and write to IBufferWriter.
    /// </summary>
    /// <param name="writer">The writer to write the disassembled method to.</param>
    /// <param name="method">The method to disassemble.</param>
    /// <param name="options">options</param>
    public void Disassemble(IBufferWriter<char> writer, MethodBase method, DisassembleOptions? options = null)
    {
        options ??= defaultOptions;


        if (method.IsGenericMethodDefinition)
        {
            if (options.WriteMethodSignature)
            {
                WriteSignatureFromReflection(writer, method);
            }

            writer.WriteLine("; Open generics cannot be JIT-compiled.");
        }
        else if (method.IsAbstract)
        {
            if (options.WriteMethodSignature)
            {
                WriteSignatureFromReflection(writer, method);
            }

            writer.WriteLine("; Abstract method cannot be JIT-compiled.");
        }
        else
        {
            DisassembleConstructedMethod(writer, method, options);
        }
    }

    void DisassembleConstructedMethod(IBufferWriter<char> writer, MethodBase method, DisassembleOptions options)
    {
        RuntimeMethodHandle handle = method.MethodHandle;
        handle.GetFunctionPointer();
        RuntimeHelpers.PrepareMethod(handle);
        ClrMethod? clrMethod;
        lock (runtime)
            runtime.FlushCachedData();
        ConfigureSymbols(runtime.DataTarget);
        if (method.IsVirtual && !method.DeclaringType!.IsClass)
        {
            clrMethod = runtime.GetMethodByInstructionPointer((ulong)FunctionPointerHelper.GetMethodPointer((System.Reflection.MethodInfo)method));
        }
        else
        {
            clrMethod = FindJitCompiledMethod(handle);
        }

        if (clrMethod == null)
        {
            writer.WriteLine("; Failed to find JIT output.");
            return;
        }

        var state = new State(runtime, "");
        state.Todo.Enqueue(new MethodInfo(clrMethod, 0));

        var isFirst = true;

        while (state.Todo.TryDequeue(out var next))
        {
            if (next.Depth > options.MaxRecursiveDepth) continue;
            if (!isFirst)
            {
                writer.WriteLine();
            }
            isFirst = false;
            clrMethod = next.Method;
            if (options.WriteMethodSignature)
            {
                writer.Write("; ");
                writer.WriteLine(clrMethod.Signature);
            }


            var methodAddress = clrMethod.NativeCode;
            var methodLength = clrMethod.HotColdInfo.HotSize;

            var codes = new byte[methodLength];
            unsafe
            {
                new Span<byte>((void*)methodAddress, (int)methodLength).CopyTo(codes);
            }

            Write(writer, state,
                Decode(codes, methodAddress, state, next.Depth, clrMethod, Convert(options.Syntax))
                , methodAddress, methodLength);


            writer.Write($"; Total method size: {methodLength} bytes");
            if (options.WriteILToNativeMap)
            {
                writer.WriteLine();
                writer.WriteLine("; IL to native map");
                var offsetMap = clrMethod.ILOffsetMap;
                if (offsetMap.Any(m => m.StartAddress < methodAddress || m.EndAddress > methodAddress + methodLength))
                {
                    writer.WriteLine("; Method was updated after first compilation. IL to native map is not available.");
                    return;
                }

                foreach (var map in offsetMap
                             .Where(map => map.ILOffset >= 0)
                             .Distinct(ILToNativeMapComparer.Instance)
                             .OrderBy(x => x.ILOffset))
                {
                    var start = map.StartAddress - methodAddress;
                    var end = map.EndAddress - methodAddress;
                    writer.WriteLine($"IL{map.ILOffset:x4} -> L{start:x4} - L{end:x4}");
                }
            }
        }
    }

    static BenchmarkDotNet.Diagnosers.DisassemblySyntax Convert(DisassemblySyntax syntax) => syntax switch
    {
        DisassemblySyntax.Intel => BenchmarkDotNet.Diagnosers.DisassemblySyntax.Intel,
        DisassemblySyntax.Masm => BenchmarkDotNet.Diagnosers.DisassemblySyntax.Masm,
        DisassemblySyntax.Att => BenchmarkDotNet.Diagnosers.DisassemblySyntax.Att,
        _ => throw new ArgumentOutOfRangeException(nameof(syntax), syntax, null)
    };

    class ILToNativeMapComparer : IEqualityComparer<ILToNativeMap>
    {
        public static readonly ILToNativeMapComparer Instance = new();
        public bool Equals(ILToNativeMap x, ILToNativeMap y) => x.ILOffset == y.ILOffset && x.StartAddress == y.StartAddress && x.EndAddress == y.EndAddress;
        public int GetHashCode(ILToNativeMap obj) => HashCode.Combine(obj.ILOffset, obj.StartAddress, obj.EndAddress);
    }

    ClrMethod? FindJitCompiledMethod(RuntimeMethodHandle handle)
    {
        var methodDescAddress = unchecked((ulong)handle.Value.ToInt64());
        if (runtime.GetMethodByHandle(methodDescAddress) is not { } method)
        {
            return null;
        }

        if (method.CompilationType == MethodCompilationType.None || method.NativeCode == 0 || method.HotColdInfo.HotSize == 0)
        {
            return null;
        }

        return method;
    }

    void WriteTypeName(IBufferWriter<char> writer, Type type)
    {
        if (type.IsGenericType)
        {
            writer.Write(type.GetGenericTypeDefinition().FullName);
            var genericArguments = type.GetGenericArguments();
            if (genericArguments.Length > 0)
            {
                writer.Write("<");
                var first = true;
                foreach (var argument in genericArguments)
                {
                    if (first)
                    {
                        first = false;
                    }
                    else
                    {
                        writer.Write(", ");
                    }

                    WriteTypeName(writer, argument);
                }

                writer.Write(">");
                return;
            }
        }

        if (type.IsByRef)
        {
            WriteTypeName(writer, type.GetElementType()!);
            writer.Write(" ByRef");
            return;
        }

        writer.Write(type.FullName ?? type.Name);
    }


    void WriteSignatureFromReflection(IBufferWriter<char> writer, MethodBase method)
    {
        writer.Write("; ");
        if (method.DeclaringType is { } declaringType)
        {
            WriteTypeName(writer, declaringType);

            writer.Write(".");
        }

        writer.Write(method.Name);
        if (method.IsGenericMethod)
        {
            writer.Write("<");
            var first = true;
            foreach (var type in method.GetGenericArguments())
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    writer.Write(", ");
                }

                WriteTypeName(writer, type);
            }

            writer.Write(">");
        }

        writer.Write("(");
        {
            var first = true;
            foreach (var parameter in method.GetParameters())
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    writer.Write(", ");
                }

                var type = parameter.ParameterType;
                WriteTypeName(writer, type);
            }
        }
        writer.WriteLine(")");
    }


    private static void ConfigureSymbols(DataTarget dataTarget)
    {
        // code copied from https://github.com/Microsoft/clrmd/issues/34#issuecomment-161926535
        dataTarget.SetSymbolPath("http://msdl.microsoft.com/download/symbols");
    }

    private protected abstract IEnumerable<Asm> Decode(byte[] code, ulong startAddress, State state, int depth, ClrMethod currentMethod, BenchmarkDotNet.Diagnosers.DisassemblySyntax syntax);

    private protected abstract void Write(IBufferWriter<char> writer, State state, IEnumerable<Asm> asms, ulong methodAddress, uint methodLength);

    protected static readonly ulong MinValidAddress = ushort.MaxValue + 1;

    private protected void TryTranslateAddressToName(ulong address, bool isAddressPrecodeMD, State state, int depth, ClrMethod currentMethod)
    {
        if (!IsValidAddress(address) || state.AddressToNameMapping.ContainsKey(address))
            return;


        var jitHelperFunctionName = runtime.GetJitHelperFunctionName(address);
        if (!string.IsNullOrEmpty(jitHelperFunctionName))
        {
            state.AddressToNameMapping.Add(address, jitHelperFunctionName);
            return;
        }

        var method = runtime.GetMethodByInstructionPointer(address);
        //var method = instruction.MemoryBase==Register.None?runtime.GetMethodByInstructionPointer(address):null;
        if (method is null && (address & ((uint)runtime.DataTarget.DataReader.PointerSize - 1)) == 0
                           && runtime.DataTarget.DataReader.ReadPointer(address, out ulong newAddress) && IsValidAddress(newAddress))
        {
            method = runtime.GetMethodByInstructionPointer(newAddress);
        }

        if (method is null)
        {
            var methodDescriptor = runtime.GetMethodByHandle(address);
            if (methodDescriptor is not null)
            {
                if (isAddressPrecodeMD)
                {
                    state.AddressToNameMapping.Add(address, $"Precode of {methodDescriptor.Signature}");
                }
                else
                {
                    state.AddressToNameMapping.Add(address, $"MD_{methodDescriptor.Signature}");
                }

                return;
            }

            var methodTableName = runtime.GetTypeByMethodTable(address)?.Name;
            if (!string.IsNullOrEmpty(methodTableName))
            {
                state.AddressToNameMapping.Add(address, $"MT_{methodTableName}");
            }

            return;
        }

        if (method.NativeCode == currentMethod.NativeCode && method.Signature == currentMethod.Signature)
            return; // in case of a call which is just a jump within the method or a recursive call

        if (!state.HandledMethods.Contains(method))
        {
            state.Todo.Enqueue(new MethodInfo(method, depth + 1));
        }

        var methodName = method.Signature!;
        if (methodName.All(c => c != '.')) // the method name does not contain namespace and type name
            methodName = $"{method.Type.Name}.{method.Signature}";
        state.AddressToNameMapping.Add(address, methodName);
    }

    protected static bool IsValidAddress(ulong address)
        // -1 (ulong.MaxValue) address is invalid, and will crash the runtime in older runtimes. https://github.com/dotnet/runtime/pull/90794
        // 0 is NULL and therefore never valid.
        // Addresses less than the minimum virtual address are also invalid.
        => address != ulong.MaxValue
           && address != 0
           && address >= MinValidAddress;

    public void Dispose()
    {
        foreach (var disposable in Disposables)
            disposable.Dispose();
        Disposables.Clear();
    }
}